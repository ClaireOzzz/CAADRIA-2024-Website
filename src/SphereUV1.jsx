/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.11 SphereUV1.glb --transform 
Files: SphereUV1.glb [4.47MB] > SphereUV1-transformed.glb [4.29MB] (4%)
*/
import React, { useRef, useEffect, useState, useMemo } from 'react'
import { useGLTF, useAnimations, useVideoTexture, useAspect, useTexture } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import { WaveShaderMaterial } from './DepthShader';
import { AnimationMixer, AnimationUtils } from 'three'

export function Model1(props) {
  const myMesh = React.useRef()
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('/SphereUV1-transformed.glb')
  const { actions } = useAnimations(animations, group)
  const { camera, viewport } = useThree();
  const [isDragging, setIsDragging] = useState(false);
  const [prevMouseX, setPrevMouseX] = useState(0);
  const [prevMouseY, setPrevMouseY] = useState(0);

  function VideoMaterial({ url }) {
    const texture = useVideoTexture(url)
    return <meshBasicMaterial map={texture} toneMapped={false} />
  }
  

  const mixer = useMemo(() => new AnimationMixer(), [])
  let value = null
  // useEffect(() => {
  //   console.log(actions)
  //   actions["Key.001Action"].play()
  // }, [])

  useEffect(() => {
        console.log(animations)
        const warp = animations[0]
        const mainPart = AnimationUtils.subclip(warp, 'trimmedWalk', 0, 99)    
        mixer.clipAction(mainPart, group.current).play()
      }, [value])  
  
  useFrame((_, delta) => {
    mixer.update(delta)
    // console.log(h)
})
  
  
    useEffect(() => {
      const handleMouseDown = () => {
        setIsDragging(true);
      };
  
      const handleMouseUp = () => {
        setIsDragging(false);
      };
  
      const handleMouseMove = (event) => {
        if (isDragging) {
          const mouseX = event.clientX;
          const mouseY = event.clientY;
          const deltaX = mouseX - prevMouseX;
          const deltaY = mouseY - prevMouseY;
          
          // Rotate mesh based on mouse movement
          myMesh.current.rotation.y += deltaX * 0.01;
          myMesh.current.rotation.x += deltaY * 0.01;
  
          setPrevMouseX(mouseX);
          setPrevMouseY(mouseY);
        }
      };
  
      window.addEventListener('mousedown', handleMouseDown);
      window.addEventListener('mouseup', handleMouseUp);
      window.addEventListener('mousemove', handleMouseMove);
  
      return () => {
        window.removeEventListener('mousedown', handleMouseDown);
        window.removeEventListener('mouseup', handleMouseUp);
        window.removeEventListener('mousemove', handleMouseMove);
      };
    }, [isDragging, prevMouseX, prevMouseY]);

  
    useFrame(({ clock }) => {
      if (!isDragging) {
        myMesh.current.rotation.x = clock.getElapsedTime() / 2;
        myMesh.current.rotation.y = clock.getElapsedTime() / 2;
        myMesh.current.rotation.z = clock.getElapsedTime() / 2;
      }
    });
    
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
        <mesh name="Cube"   ref={myMesh}
        geometry={nodes.Cube.geometry} 
        // material={materials.Material} 
        morphTargetDictionary={nodes.Cube.morphTargetDictionary} 
        morphTargetInfluences={nodes.Cube.morphTargetInfluences} >
          {/* <meshBasicMaterial map={texture} toneMapped={false} /> */}
          <VideoMaterial url="vid1.mp4" />
         </mesh>
      </group>
    </group>
  )
}

useGLTF.preload('/SphereUV1-transformed.glb')
