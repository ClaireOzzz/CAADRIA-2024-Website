/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.11 SphereUV2.glb --transform 
Files: SphereUV2.glb [4.51MB] > SphereUV2-transformed.glb [4.3MB] (5%)
*/

// import React, { useRef } from 'react'
// import { useGLTF, useAnimations } from '@react-three/drei'

// export function Model(props) {
//   const group = useRef()
//   const { actions } = useAnimations(animations, group)
//   return (
//     <group ref={group} {...props} dispose={null}>
//       <group name="Scene">
//         <mesh name="Cube003" geometry={nodes.Cube003.geometry} material={materials.Material} morphTargetDictionary={nodes.Cube003.morphTargetDictionary} morphTargetInfluences={nodes.Cube003.morphTargetInfluences} rotation={[0.02, 0.02, -0.02]} />
//       </group>
//     </group>
//   )
// }


/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.11 SphereUV1.glb --transform 
Files: SphereUV1.glb [4.47MB] > SphereUV1-transformed.glb [4.29MB] (4%)
*/
import React, { useRef, useEffect, useState, useMemo } from 'react'
import { useGLTF, useAnimations, useVideoTexture, useAspect, useTexture } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import { WaveShaderMaterial } from './DepthShader';
import { AnimationMixer, AnimationUtils } from 'three'

export function Model2(props) {
  const myMesh = React.useRef()
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('/SphereUV2-transformed.glb')
  const { actions } = useAnimations(animations, group)
  const { camera, viewport } = useThree();
  const [isDragging, setIsDragging] = useState(false);
  const [prevMouseX, setPrevMouseX] = useState(0);
  const [prevMouseY, setPrevMouseY] = useState(0);

  function VideoMaterial({ url }) {
    const texture = useVideoTexture(url)
    return <meshBasicMaterial map={texture} toneMapped={false} />
  }
  

  const mixer = useMemo(() => new AnimationMixer(), [])
  let value = null
  useEffect(() => {
    console.log(animations)
    const warp = animations[0]
    const mainPart = AnimationUtils.subclip(warp, 'trimmedWalk', 0, 99)    
    mixer.clipAction(mainPart, group.current).play()
  }, [value])  

 
  
  useFrame((_, delta) => {
    mixer.update(delta)
    // console.log(h)
})
  
  
    useEffect(() => {
      const handleMouseDown = () => {
        setIsDragging(true);
      };
  
      const handleMouseUp = () => {
        setIsDragging(false);
      };
  
      const handleMouseMove = (event) => {
        if (isDragging) {
          const mouseX = event.clientX;
          const mouseY = event.clientY;
          const deltaX = mouseX - prevMouseX;
          const deltaY = mouseY - prevMouseY;
          
          // Rotate mesh based on mouse movement
          myMesh.current.rotation.y += deltaX * 0.01;
          myMesh.current.rotation.x += deltaY * 0.01;
  
          setPrevMouseX(mouseX);
          setPrevMouseY(mouseY);
        }
      };
  
      window.addEventListener('mousedown', handleMouseDown);
      window.addEventListener('mouseup', handleMouseUp);
      window.addEventListener('mousemove', handleMouseMove);
  
      return () => {
        window.removeEventListener('mousedown', handleMouseDown);
        window.removeEventListener('mouseup', handleMouseUp);
        window.removeEventListener('mousemove', handleMouseMove);
      };
    }, [isDragging, prevMouseX, prevMouseY]);

  
    useFrame(({ clock }) => {
      if (!isDragging) {
        myMesh.current.rotation.x = clock.getElapsedTime() / 2;
        myMesh.current.rotation.y = clock.getElapsedTime() / 2;
        myMesh.current.rotation.z = clock.getElapsedTime() / 2;
      }
    });
    
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
      <mesh name="Cube003"   ref={myMesh}
      geometry={nodes.Cube003.geometry} 
      // material={materials.Material} 
      morphTargetDictionary={nodes.Cube003.morphTargetDictionary} 
      morphTargetInfluences={nodes.Cube003.morphTargetInfluences} 
       >
      <VideoMaterial url="vid3.mp4" />
      </mesh>
      </group>
    </group>
  )
}
useGLTF.preload('/SphereUV2-transformed.glb')

