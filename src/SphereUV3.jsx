/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
Command: npx gltfjsx@6.2.11 SphereUV3.glb --transform 
Files: SphereUV3.glb [4.48MB] > SphereUV3-transformed.glb [4.28MB] (4%)
*/
import React, { useRef, useEffect, useState, useMemo } from 'react'
import { useGLTF, useAnimations, useVideoTexture, useAspect, useTexture } from '@react-three/drei'
import { useFrame, useThree } from '@react-three/fiber'
import { AnimationMixer, AnimationUtils } from 'three'

export function Model3(props) {
  const myMesh = React.useRef()
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('/SphereUV3-transformed.glb')

  const { actions } = useAnimations(animations, group)
  const { camera, viewport } = useThree();
  const [isDragging, setIsDragging] = useState(false);
  const [prevMouseX, setPrevMouseX] = useState(0);
  const [prevMouseY, setPrevMouseY] = useState(0);

  function VideoMaterial({ url }) {
    const texture = useVideoTexture(url)
    texture.rotation = Math.PI / 2
    console.log(texture)
    return <meshBasicMaterial map={texture} toneMapped={true} />
  }

  const mixer = useMemo(() => new AnimationMixer(), [])
  let value = null
  useEffect(() => {
    console.log(animations)
    const warp = animations[0]
    const mainPart = AnimationUtils.subclip(warp, 'trimmedWalk', 0, 99)    
    mixer.clipAction(mainPart, group.current).play()
  }, [value])  

 
  
  useFrame((_, delta) => {
    mixer.update(delta)
    // console.log(h)
})
  
  
    useEffect(() => {
      const handleMouseDown = () => {
        setIsDragging(true);
      };
  
      const handleMouseUp = () => {
        setIsDragging(false);
      };
  
      const handleMouseMove = (event) => {
        if (isDragging) {
          const mouseX = event.clientX;
          const mouseY = event.clientY;
          const deltaX = mouseX - prevMouseX;
          const deltaY = mouseY - prevMouseY;
          
          // Rotate mesh based on mouse movement
          myMesh.current.rotation.y += deltaX * 0.01;
          myMesh.current.rotation.x += deltaY * 0.01;
  
          setPrevMouseX(mouseX);
          setPrevMouseY(mouseY);
        }
      };
  
      window.addEventListener('mousedown', handleMouseDown);
      window.addEventListener('mouseup', handleMouseUp);
      window.addEventListener('mousemove', handleMouseMove);
  
      return () => {
        window.removeEventListener('mousedown', handleMouseDown);
        window.removeEventListener('mouseup', handleMouseUp);
        window.removeEventListener('mousemove', handleMouseMove);
      };
    }, [isDragging, prevMouseX, prevMouseY]);

  
    useFrame(({ clock }) => {
      if (!isDragging) {
        myMesh.current.rotation.x = clock.getElapsedTime() / 2;
        myMesh.current.rotation.y = clock.getElapsedTime() / 2;
        myMesh.current.rotation.z = clock.getElapsedTime() / 2;
      }
    });
    
  return (
    <group ref={group} {...props} dispose={null}>
      <group name="Scene">
      <mesh name="Cube003" ref={myMesh}
      geometry={nodes.Cube003.geometry} 
      material={materials.Material} 
      morphTargetDictionary={nodes.Cube003.morphTargetDictionary} 
      morphTargetInfluences={nodes.Cube003.morphTargetInfluences} 
       >
      <VideoMaterial url="vid2.mp4" />
      </mesh>
      </group>
    </group>
  )
}

useGLTF.preload('/SphereUV3-transformed.glb')

